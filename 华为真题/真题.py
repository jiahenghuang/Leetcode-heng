#coding:utf-8

# 裁剪布匹的问题，如果第二个布匹比前一个布匹的长宽都大，则不需要时间重制裁剪机器，否则需要花费1min重制机器，
# 会给你一个序列，让你找出最优的序列，用时最少。其实就是求最少的上升子序列。

# 链接：https://www.nowcoder.com/questionTerminal/dcb97b18715141599b64dbdb8cdea3bd
# 一个数的序列bi，当b1 < b2 < ... < bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ... < iK <= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和. 你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)。

# 输入描述:
# 输入包含多组测试数据。
# 每组测试数据由两行组成。第一行是序列的长度N (1 <= N <= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。

# 输出描述:
# 对于每组测试数据，输出其最大上升子序列和。

#又是神奇的动态规划
#先求最大上升子序列的长度
#分析思路，仍然是倒着分析
#假设dp[i]是以第i个位置为端点的最长子序列
#那么dp[i]=max(dp[j])+1,其中dp[j]需要满足情况：j < i,dp[j]<dp[i] 

#迭代法      
class Solution():
    def longestList(self, llist):
        if llist is None:return 0
        dp = len(llist)*[0]
        for i in range(len(llist)):
            for j in range(i):
                if llist[j]<llist[i]:
                    dp[i] = max(dp[j] + 1,dp[i])
        return max(dp)

if __name__=='__main__':
    llist=[]
    Solution().longestList(llist)
